/**
 * Script to minify JavaScript and TypeScript files in the public/scripts directory
 * - Processes all .js/.ts files (except those already minified)
 * - Compiles TypeScript files to JavaScript
 * - Skips files that haven't changed since last minification
 * - Creates .min.js versions with the same base name
 * Generated by Claude (claude-3.7-sonnet-thinking)
 */

import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import { fileURLToPath } from 'node:url'
import { build } from 'esbuild'

// ANSI color codes for terminal output (only used colors)
const colors = {
  reset: '\x1B[0m',
  bright: '\x1B[1m',
  dim: '\x1B[2m',
  // Text colors
  black: '\x1B[30m',
  white: '\x1B[37m',
  red: '\x1B[31m',
  green: '\x1B[32m',
  yellow: '\x1B[33m',
  blue: '\x1B[34m',
  // Background colors
  bgGreen: '\x1B[42m',
  bgRed: '\x1B[41m',
  bgBlack: '\x1B[40m',
}

// Get current directory and scripts paths
const __dirname = path.dirname(fileURLToPath(import.meta.url))
const scriptsDir = path.resolve(__dirname, '../src/public-scripts')
const publicScriptsDir = path.resolve(__dirname, '../public/scripts')

// Track stats
let processedCount = 0
let totalInputSize = 0
let totalOutputSize = 0
const startTime = Date.now()

/**
 * Format file size in a human-readable format
 * @param {number} bytes - Size in bytes
 * @returns {string} Formatted size
 */
function formatSize(bytes) {
  if (bytes < 1024) {
    return `${bytes} B`
  }
  if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(2)} kB`
  }
  return `${(bytes / (1024 * 1024)).toFixed(2)} MB`
}

/**
 * Get formatted timestamp
 * @returns {string} Current time in HH:MM:SS format
 */
function getTimestamp() {
  const now = new Date()
  return now.toTimeString().substring(0, 8)
}

/**
 * Log a message with timestamp and category
 * @param {string} category - Message category
 * @param {string} message - Message content
 * @param {string} categoryColor - Color for the category
 */
function log(category, message, categoryColor = colors.blue) {
  console.log(`${colors.dim}${getTimestamp()}${colors.reset} ${categoryColor}[${category}]${colors.reset} ${message}`)
}

/**
 * Log a standalone group title with green background (Astro style)
 * @param {string} title - The group title
 * @param {string} details - Additional details
 */
function logGroup(title, details = '') {
  // Add space before the group
  console.log('')

  // Print the group title with Astro-style formatting
  if (details) {
    console.log(
      `${colors.bgGreen}${colors.white} ${title} ${colors.reset}${colors.bgBlack}${colors.dim} (${details}) ${colors.reset}`,
    )
  } else {
    console.log(`${colors.bgGreen}${colors.white} ${title} ${colors.reset}`)
  }

  console.log('')
}

/**
 * Log an error message (Astro style)
 * @param {string} message - Main message content
 * @param {string} [details] - Optional details
 */
function logError(message, details = '') {
  const badge = `${colors.bgRed}${colors.black} error ${colors.reset}`
  log(
    'minify',
    `${badge} ${colors.red}${message}${colors.reset}${details ? `\n  ${colors.dim}▶ ${details}${colors.reset}` : ''}`,
    colors.blue,
  )
}

/**
 * Get the base name of a file without extension
 * @param {string} filename - The filename with extension
 * @returns {string} The base name without extension
 */
function getBaseName(filename) {
  return path.basename(filename, path.extname(filename))
}

/**
 * Process TypeScript files to JavaScript
 * @param {string} inputFile - Source file path
 * @param {string} outputFile - Output file path
 * @returns {Promise<void>}
 */
async function compileTypeScript(inputFile, outputFile) {
  try {
    await build({
      entryPoints: [inputFile],
      outfile: outputFile,
      minify: false, // Don't minify yet, will be done in the next step
      bundle: false,
      write: true,
      format: 'esm',
      target: 'es2020',
      platform: 'browser',
    })

    // Calculate file sizes
    const inputStats = fs.statSync(inputFile)
    const outputStats = fs.statSync(outputFile)
    const inputSize = inputStats.size
    const outputSize = outputStats.size

    // Update totals for TS compilation
    log(
      'compile',
      `${colors.bright}${path.basename(outputFile)}${colors.reset}  ${formatSize(outputSize)} ${colors.dim}|${colors.reset} compiled from TS`,
    )

    return { success: true, size: inputSize }
  } catch (err) {
    logError(`Failed to compile TypeScript ${path.basename(inputFile)}`, err.message)
    return { success: false, size: 0 }
  }
}

/**
 * Minify a JavaScript file
 * @param {string} inputFile - Source file path
 * @param {string} outputFile - Output minified file path
 * @returns {Promise<void>}
 */
async function minifyFile(inputFile, outputFile) {
  try {
    await build({
      entryPoints: [inputFile],
      outfile: outputFile,
      minify: true,
      bundle: false,
      write: true,
    })

    // Calculate file sizes
    const inputStats = fs.statSync(inputFile)
    const outputStats = fs.statSync(outputFile)
    const inputSize = inputStats.size
    const outputSize = outputStats.size
    const savings = ((1 - outputSize / inputSize) * 100).toFixed(1)

    // Update totals
    totalInputSize += inputSize
    totalOutputSize += outputSize
    processedCount++

    // Log with color and formatting (Astro style)
    log(
      'minify',
      `${colors.bright}${path.basename(outputFile)}${colors.reset}  ${formatSize(outputSize)} ${colors.dim}|${colors.reset} saved: ${colors.green}${savings}%${colors.reset}`,
    )

    return { success: true }
  } catch (err) {
    logError(`Failed to minify ${path.basename(inputFile)}`, err.message)
    return { success: false }
  }
}

/**
 * Process TypeScript files, then minify the resulting JS
 * @param {string} inputFile - Source TS file path
 * @param {string} outputFile - Output minified JS file path
 * @returns {Promise<boolean>} Success or failure
 */
async function processTypeScriptFile(inputFile, outputFile) {
  // First compile TS to JS (intermediate file in the source directory)
  const baseName = getBaseName(inputFile)
  const intermediateFile = path.join(scriptsDir, `${baseName}.js`)

  // Compile TypeScript to JavaScript
  const compileResult = await compileTypeScript(inputFile, intermediateFile)
  if (!compileResult.success) {
    return false
  }

  // Add the TypeScript file size to the total input size
  totalInputSize += compileResult.size

  // Then minify the resulting JS file
  const minifyResult = await minifyFile(intermediateFile, outputFile)

  // Clean up the intermediate file after processing
  try {
    if (path.basename(inputFile) !== path.basename(intermediateFile)) {
      // Only delete if we created a new intermediate file
      fs.unlinkSync(intermediateFile)
    }
  } catch {
    log('minify', `${colors.yellow}Warning: Could not clean up temporary file ${path.basename(intermediateFile)}${colors.reset}`)
  }

  return minifyResult.success
}

/**
 * Check if a file needs processing based on timestamps
 * @param {string} inputFile - Source file path
 * @param {string} outputFile - Output file path
 * @returns {boolean} True if the file needs processing
 */
function needsProcessing(inputFile, outputFile) {
  const inputStat = fs.statSync(inputFile)

  try {
    const outputStat = fs.statSync(outputFile)
    if (outputStat.mtimeMs > inputStat.mtimeMs) {
      // Output is newer than input, skip processing
      return false
    }
  } catch {
    // Output file doesn't exist, needs processing
  }

  return true
}

/**
 * Process all script files in the scripts directory
 */
async function processScriptsDirectory() {
  // Make sure the output directory exists
  if (!fs.existsSync(publicScriptsDir)) {
    fs.mkdirSync(publicScriptsDir, { recursive: true })
  }

  // Display the group header (Astro style)
  logGroup('minifying public scripts', 'esbuild')

  // Read all files in the scripts directory
  const files = fs.readdirSync(scriptsDir)

  // Count total files to process
  const scriptFiles = files.filter(file =>
    (file.endsWith('.js') || file.endsWith('.ts'))
    && !file.endsWith('.min.js')
    && !file.endsWith('.d.ts'),
  )

  if (scriptFiles.length === 0) {
    log('minify', `${colors.yellow}No JavaScript or TypeScript files found to process${colors.reset}`)
    // Add blank line after group
    console.log('')
    return
  }

  // Process all valid script files
  for (const file of scriptFiles) {
    const inputFile = path.join(scriptsDir, file)
    const isTypeScript = file.endsWith('.ts')
    const baseName = getBaseName(file)
    const outputFile = path.join(publicScriptsDir, `${baseName}.min.js`)

    // Check if processing is needed
    if (!needsProcessing(inputFile, outputFile)) {
      log('minify', `Skipping ${colors.yellow}${file}${colors.reset}: Already up to date`)
      continue
    }

    // Process the file
    if (isTypeScript) {
      await processTypeScriptFile(inputFile, outputFile)
    } else {
      await minifyFile(inputFile, outputFile)
    }
  }

  // Report summary (Astro style)
  const endTime = Date.now()
  const duration = endTime - startTime

  // Report if no files needed processing
  if (processedCount === 0) {
    log('minify', `${colors.green}✓ All files are already up to date${colors.reset}`)
  } else {
    const savingsPercent = ((1 - totalOutputSize / totalInputSize) * 100).toFixed(1)
    log(
      'minify',
      `${colors.green}✓ Completed in ${duration}ms${processedCount > 0 ? ` (processed ${processedCount} file${processedCount > 1 ? 's' : ''}, saved ${savingsPercent}%)` : ''}${colors.reset}`,
    )
  }

  // Add blank line after group
  console.log('')
}

// Execute the main function
processScriptsDirectory().catch((err) => {
  logError(`Unhandled exception`, err.stack || err)
  process.exit(1)
})
