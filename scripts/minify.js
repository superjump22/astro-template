/**
 * Script to minify JavaScript files in the public/scripts directory
 * - Processes all .js files (except those already minified)
 * - Skips files that haven't changed since last minification
 * - Creates .min.js versions with the same base name
 * Generated by Claude (claude-3.7-sonnet-thinking)
 */

import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import { fileURLToPath } from 'node:url'
import { build } from 'esbuild'

// ANSI color codes for terminal output (only used colors)
const colors = {
  reset: '\x1B[0m',
  bright: '\x1B[1m',
  dim: '\x1B[2m',
  // Text colors
  black: '\x1B[30m',
  white: '\x1B[37m',
  red: '\x1B[31m',
  green: '\x1B[32m',
  yellow: '\x1B[33m',
  blue: '\x1B[34m',
  // Background colors
  bgGreen: '\x1B[42m',
  bgRed: '\x1B[41m',
  bgBlack: '\x1B[40m',
}

// Get current directory and public/scripts path
const __dirname = path.dirname(fileURLToPath(import.meta.url))
const scriptsDir = path.resolve(__dirname, '../public/scripts')

// Track stats
let processedCount = 0
let totalInputSize = 0
let totalOutputSize = 0
const startTime = Date.now()

/**
 * Format file size in a human-readable format
 * @param {number} bytes - Size in bytes
 * @returns {string} Formatted size
 */
function formatSize(bytes) {
  if (bytes < 1024) {
    return `${bytes} B`
  }
  if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(2)} kB`
  }
  return `${(bytes / (1024 * 1024)).toFixed(2)} MB`
}

/**
 * Get formatted timestamp
 * @returns {string} Current time in HH:MM:SS format
 */
function getTimestamp() {
  const now = new Date()
  return now.toTimeString().substring(0, 8)
}

/**
 * Log a message with timestamp and category
 * @param {string} category - Message category
 * @param {string} message - Message content
 * @param {string} categoryColor - Color for the category
 */
function log(category, message, categoryColor = colors.blue) {
  console.log(`${colors.dim}${getTimestamp()}${colors.reset} ${categoryColor}[${category}]${colors.reset} ${message}`)
}

/**
 * Log a standalone group title with green background (Astro style)
 * @param {string} title - The group title
 * @param {string} details - Additional details
 */
function logGroup(title, details = '') {
  // Add space before the group
  console.log('')

  // Print the group title with Astro-style formatting
  if (details) {
    console.log(
      `${colors.bgGreen}${colors.white} ${title} ${colors.reset}${colors.bgBlack}${colors.dim} (${details}) ${colors.reset}`,
    )
  } else {
    console.log(`${colors.bgGreen}${colors.white} ${title} ${colors.reset}`)
  }

  console.log('')
}

/**
 * Log an error message (Astro style)
 * @param {string} message - Main message content
 * @param {string} [details] - Optional details
 */
function logError(message, details = '') {
  const badge = `${colors.bgRed}${colors.black} error ${colors.reset}`
  log(
    'minify',
    `${badge} ${colors.red}${message}${colors.reset}${details ? `\n  ${colors.dim}▶ ${details}${colors.reset}` : ''}`,
    colors.blue,
  )
}

/**
 * Minify a JavaScript file
 * @param {string} inputFile - Source file path
 * @param {string} outputFile - Output minified file path
 * @returns {Promise<void>}
 */
async function minifyFile(inputFile, outputFile) {
  try {
    await build({
      entryPoints: [inputFile],
      outfile: outputFile,
      minify: true,
      bundle: false,
      write: true,
    })

    // Calculate file sizes
    const inputStats = fs.statSync(inputFile)
    const outputStats = fs.statSync(outputFile)
    const inputSize = inputStats.size
    const outputSize = outputStats.size
    const savings = ((1 - outputSize / inputSize) * 100).toFixed(1)

    // Update totals
    totalInputSize += inputSize
    totalOutputSize += outputSize
    processedCount++

    // Log with color and formatting (Astro style)
    log(
      'minify',
      `${colors.bright}${path.basename(outputFile)}${colors.reset}  ${formatSize(outputSize)} ${colors.dim}|${colors.reset} saved: ${colors.green}${savings}%${colors.reset}`,
    )
  } catch (err) {
    logError(`Failed to minify ${path.basename(inputFile)}`, err.message)
  }
}

/**
 * Process all JavaScript files in the scripts directory
 */
async function processScriptsDirectory() {
  // Display the group header (Astro style)
  logGroup('minifying public scripts', 'esbuild')

  // Read all files in the scripts directory
  const files = fs.readdirSync(scriptsDir)

  // Count total files to process
  const jsFiles = files.filter(file => file.endsWith('.js') && !file.endsWith('.min.js'))
  if (jsFiles.length === 0) {
    log('minify', `${colors.yellow}No JavaScript files found to process${colors.reset}`)
    // Add blank line after group
    console.log('')
    return
  }

  // Filter and process .js files
  for (const file of files) {
    // Only process .js files that aren't already minified
    if (file.endsWith('.js') && !file.endsWith('.min.js')) {
      const inputFile = path.join(scriptsDir, file)
      const outputFile = path.join(scriptsDir, file.replace('.js', '.min.js'))

      // Check if output file exists and is newer than input file
      const inputStat = fs.statSync(inputFile)
      let shouldProcess = true

      try {
        const outputStat = fs.statSync(outputFile)
        if (outputStat.mtimeMs > inputStat.mtimeMs) {
          shouldProcess = false
          log('minify', `Skipping ${colors.yellow}${file}${colors.reset}: Already up to date`)
        }
      } catch {
        // Output file doesn't exist, proceed with processing
      }

      if (shouldProcess) {
        await minifyFile(inputFile, outputFile)
      }
    }
  }

  // Report summary (Astro style)
  const endTime = Date.now()
  const duration = endTime - startTime

  // Report if no files needed processing
  if (processedCount === 0) {
    log('minify', `${colors.green}✓ All files are already up to date${colors.reset}`)
  } else {
    const savingsPercent = ((1 - totalOutputSize / totalInputSize) * 100).toFixed(1)
    log(
      'minify',
      `${colors.green}✓ Completed in ${duration}ms${processedCount > 0 ? ` (processed ${processedCount} file${processedCount > 1 ? 's' : ''}, saved ${savingsPercent}%)` : ''}${colors.reset}`,
    )
  }

  // Add blank line after group
  console.log('')
}

// Execute the main function
processScriptsDirectory().catch((err) => {
  logError(`Unhandled exception`, err.stack || err)
  process.exit(1)
})
